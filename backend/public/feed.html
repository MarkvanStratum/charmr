<script>
  // Same-origin backend (public /api/operator/feed)
  const BACKEND_URL = window.location.origin;

  let timer = null;
  let lastNow = null;            // server "now" from last poll
  const seenIds = new Set();     // dedupe & keep everything
  const rowsById = new Map();    // (optional) if you ever want updates

  const els = {
    startBtn: document.getElementById('startBtn'),
    stopBtn: document.getElementById('stopBtn'),
    status: document.getElementById('status'),
    autoScroll: document.getElementById('autoScroll'),
    limit: document.getElementById('limit'),
    body: document.getElementById('feedBody')
  };

  // Build one <tr> for a row
  function buildRow(r) {
    const tr = document.createElement('tr');
    tr.dataset.id = r.id;

    const tdTime = document.createElement('td');
    tdTime.textContent = new Date(r.createdAt).toLocaleString();

    const tdUser = document.createElement('td');
    tdUser.textContent = r.userId;

    const tdGirlId = document.createElement('td');
    tdGirlId.textContent = r.girlId;

    const tdGirlName = document.createElement('td');
    tdGirlName.textContent = r.girlName || 'Unknown';

    const tdFrom = document.createElement('td');
    tdFrom.innerHTML = r.from === 'user'
      ? '<span class="dir-user">user</span>'
      : '<span class="dir-girl">girl</span>';

    const tdMsg = document.createElement('td');
    const m = /^IMAGE:\s*(.+)$/i.exec(r.text || "");
    if (m) {
      const url = m[1].trim();
      const a = document.createElement('a');
      a.href = url; a.target = "_blank"; a.rel = "noopener";
      const img = document.createElement('img');
      img.src = url; img.alt = 'image'; img.className = 'img-thumb';
      a.appendChild(img);
      tdMsg.appendChild(a);
    } else {
      tdMsg.textContent = r.text;
    }

    tr.append(tdTime, tdUser, tdGirlId, tdGirlName, tdFrom, tdMsg);
    return tr;
  }

  // Initial render: draw a full list (DESC by created_at from server) without clearing later
  function initialRender(rows) {
    // Newest first already; just add, skipping ids we've seen
    for (const r of rows) {
      if (seenIds.has(r.id)) continue;
      const tr = buildRow(r);
      els.body.appendChild(tr);       // appending preserves DESC order returned
      seenIds.add(r.id);
      rowsById.set(r.id, r);
    }
    // Ensure newest stays visible
    if (els.autoScroll.checked) {
      const container = els.body.parentElement.parentElement.parentElement;
      container.scrollTop = 0;
    }
  }

  // Incremental: prepend only new rows (keep everything else)
  function prependNew(rows) {
    // rows are DESC (newest first). Iterate from last to first so the final DOM order is correct when inserting at top.
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = rows[i];
      if (seenIds.has(r.id)) continue;
      const tr = buildRow(r);
      // Insert at top
      if (els.body.firstChild) {
        els.body.insertBefore(tr, els.body.firstChild);
      } else {
        els.body.appendChild(tr);
      }
      seenIds.add(r.id);
      rowsById.set(r.id, r);
    }
    if (rows.length && els.autoScroll.checked) {
      const container = els.body.parentElement.parentElement.parentElement;
      container.scrollTop = 0;
    }
  }

  async function tick(isFirst = false) {
    try {
      const limit = Math.min(Math.max(parseInt(els.limit.value || '100', 10), 1), 500);
      const params = new URLSearchParams();
      params.set('limit', String(limit));
      if (!isFirst && lastNow) params.set('since', lastNow);

      const url = `${BACKEND_URL}/api/operator/feed?${params.toString()}`;
      const res = await fetch(url);
      if (!res.ok) {
        const txt = await res.text().catch(()=> '');
        throw new Error(`HTTP ${res.status} ${txt ? '— ' + txt.slice(0,150) : ''}`);
      }

      const payload = await res.json();
      const rows = payload.rows || [];

      if (isFirst) {
        // First load: draw a big slice (e.g., 100/500). They will STAY.
        initialRender(rows);
      } else {
        // Subsequent polls: only new items since last poll; prepend them.
        prependNew(rows);
      }

      lastNow = payload.now;
      els.status.textContent = `Last update: ${new Date(lastNow).toLocaleTimeString()} (total rows shown: ${seenIds.size})`;
    } catch (e) {
      els.status.textContent = `Error: ${e.message}`;
      console.error('Feed error:', e);
    }
  }

  function start() {
    if (timer) return;
    // Reset only the polling cursor; DO NOT clear the table
    lastNow = null;
    tick(true);                      // initial bulk load (kept)
    timer = setInterval(() => tick(false), 2000);
    els.startBtn.disabled = true;
    els.stopBtn.disabled = false;
  }

  function stop() {
    if (!timer) return;
    clearInterval(timer);
    timer = null;
    els.startBtn.disabled = false;
    els.stopBtn.disabled = true;
  }

  els.startBtn.addEventListener('click', start);
  els.stopBtn.addEventListener('click', stop);

  // If you change the limit while running, reload initial slice once
  els.limit.addEventListener('change', () => {
    if (!timer) return;
    // Don’t clear existing rows; just fetch more next cycle as initial again
    clearInterval(timer);
    timer = null;
    lastNow = null;
    tick(true).then(() => {
      timer = setInterval(() => tick(false), 2000);
    });
  });
</script>
