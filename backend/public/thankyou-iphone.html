<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>iPhone Thank You | Charmr</title>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDQ6REQWS8"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-FDQ6REQWS8');
  </script>

  <style>
    body { font-family: Arial, sans-serif; background:#f4f4f4; display:flex; align-items:center; justify-content:center; height:100vh; margin:0; }
    .container { background:white; padding:2rem 3rem; text-align:center; border-radius:12px; box-shadow:0 4px 15px rgba(0,0,0,.1); }
    p { font-size:1.25rem; margin:0; color:#111827; }
  </style>

  <!-- ====== SALES POSTBACK GATE (runs BEFORE loader) ====== -->
  <script>
    (function(){
      const CONFIG = { percent: 50 }; // changeable later if needed

      // Simple stable 32-bit hash
      function hash32(str){
        let h = 0;
        for (let i = 0; i < str.length; i++) {
          h = ((h << 5) - h + str.charCodeAt(i)) | 0;
        }
        return h | 0;
      }

      function shouldPost(orderId){
        const p = Math.max(0, Math.min(100, parseInt(CONFIG.percent || 0, 10)));
        if (p === 0) return false;
        if (p === 100) return true;
        const id = String(orderId || "NO-ID");
        // true 0–100 bucket so 50% works for any percent (not just %2)
        const bucket = Math.abs(hash32(id)) % 100; // 0..99
        return bucket < p;
      }

      function getOrderIdFrom(payload){
        return (payload && (payload.number || payload.order_id || payload.id))
            || (window.goaffpro_order && window.goaffpro_order.number)
            || null;
      }

      // Intercept assignment to window.goaffproTrackConversion using a setter
      let _originalSetterWrapped = false;
      Object.defineProperty(window, "goaffproTrackConversion", {
        configurable: true,
        enumerable: true,
        set(fn){
          if (typeof fn === "function" && !_originalSetterWrapped) {
            const original = fn;
            const wrapped = function(payload){
              const orderId = getOrderIdFrom(payload);
              if (shouldPost(orderId)) {
                return original.apply(this, arguments);
              } else {
                console.log("[GoAffPro Gate] Skipped posting (", CONFIG.percent, "% gate). Order:", orderId);
              }
            };
            // replace with our wrapped version
            Object.defineProperty(window, "goaffproTrackConversion", {
              value: wrapped,
              writable: false,
              configurable: true,
              enumerable: true
            });
            // mark we’ve wrapped it, and expose original for debugging if needed
            window.__goaffproTrackConversionOriginal = original;
            console.log("[GoAffPro Gate] Intercept installed; gating at", CONFIG.percent + "%");
          } else {
            // if something non-function tries to set it, just store it
            Object.defineProperty(window, "goaffproTrackConversion", {
              value: fn,
              writable: true,
              configurable: true,
              enumerable: true
            });
          }
        },
        get(){
          return undefined; // until pixel sets it, getter returns undefined
        }
      });

      // Helper to wait until our wrapped function exists
      window.__ensureGaffproPatched = function(cb){
        (function wait(){
          if (typeof window.goaffproTrackConversion === "function" &&
              typeof window.__goaffproTrackConversionOriginal === "function") {
            cb();
          } else {
            setTimeout(wait, 100);
          }
        })();
      };
    })();
  </script>
  <!-- ====== END GATE ====== -->
</head>
<body>
  <div class="container">
    <p>Thank you for your order. You’ll be contacted shortly with the details.</p>
  </div>

  <!-- Load GoAffPro AFTER the gate so we always wrap it -->
  <script src="https://api.goaffpro.com/loader.js?shop=nzyvwvfbde"></script>

  <script>
    // ---- helpers ----
    function uniqueOrderId() {
      const ts = Date.now();
      const rand = Math.random().toString(16).slice(2, 6);
      return `ORD-${new Date().toISOString().slice(0,10).replace(/-/g,'')}-${ts}-${rand}`;
    }

    // GEO-BASED AMOUNT: US/GB/AU/NZ => $30, others => $10
    async function resolveGeoAmount() {
      const preferred = ["US","GB","AU","NZ"];
      let code = "";
      try {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), 2500);
        const resp = await fetch("https://ipapi.co/json/", { signal: controller.signal });
        clearTimeout(timer);
        if (resp.ok) {
          const data = await resp.json();
          code = (data && (data.country_code || data.country) || "").toString().toUpperCase();
        }
      } catch(e) { /* default below */ }
      return preferred.includes(code) ? 30 : 10;
    }

    // Prevent double-fire in the same session
    if (!sessionStorage.getItem('gaffpro_converted')) {
      (async function () {
        const saleAmount = await resolveGeoAmount();

        // Define the order object (ID is stable for hashing)
        window.goaffpro_order = {
          number: uniqueOrderId(),
          total: saleAmount,
          currency: "USD"
        };

        // Fire ONLY after the gate-wrapped function exists
        __ensureGaffproPatched(function(){
          console.log("GoAffPro: firing conversion", window.goaffpro_order);
          window.goaffproTrackConversion(window.goaffpro_order);
          sessionStorage.setItem('gaffpro_converted', '1');
        });
      })();
    } else {
      console.log("GoAffPro: conversion already fired in this session");
    }
  </script>
</body>
</html>
