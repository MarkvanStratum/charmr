<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Operator Console</title>
  <style>
    :root { --pink:#ef476f; --ink:#222; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --sub:#6b7280; --ok:#10b981; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); color:var(--ink); }
    header { padding:12px 14px; border-bottom:1px solid var(--line); background:#fff; position:sticky; top:0; z-index:3; }
    h1 { margin:0; font-size:18px; }
    .topbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px; }
    .topbar > * { margin:0; }
    label { font-weight:600; font-size:12px; color:#444; display:block; margin-bottom:4px; }
    input, button { padding:9px 10px; font-size:14px; border-radius:10px; border:1px solid var(--line); }
    input:focus { outline:2px solid #c8e3ff; border-color:#9ccaff; }
    button { background: var(--pink); color:#fff; border:none; cursor:pointer; }
    button.secondary { background:#555; }
    button.ghost { background:#fff; color:#111; border:1px solid var(--line); }
    button:disabled { opacity:.6; cursor:not-allowed; }

    /* Layout */
    .app { display:grid; grid-template-columns: 300px 1fr; height: calc(100vh - 70px); }
    .sidebar { border-right:1px solid var(--line); background:#fff; display:flex; flex-direction:column; }
    .side-head { padding:10px; border-bottom:1px solid var(--line); display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .side-list { overflow:auto; padding:8px; flex:1; }
    .conv { display:flex; align-items:center; gap:8px; padding:10px; border:1px solid transparent; border-radius:10px; cursor:pointer; }
    .conv:hover { background:#fafafa; }
    .conv.active { border-color:#ffd1e0; background:#fff5f7; }
    .conv .meta { font-size:12px; color:var(--sub); }
    .badge { margin-left:auto; min-width:18px; height:18px; padding:0 6px; border-radius:999px; background:var(--pink); color:#fff; font-size:11px; display:flex; align-items:center; justify-content:center; }
    .dot { width:8px; height:8px; border-radius:999px; background:#cbd5e1; margin-left:6px; }
    .dot.online { background: var(--ok); box-shadow:0 0 0 3px #e7f9f1 inset; }

    .side-foot { padding:8px 10px; border-top:1px solid var(--line); font-size:12px; color:var(--sub); background:#fff; }
    .side-foot code { background:#f3f4f6; padding:2px 6px; border-radius:6px; }

    .main { display:flex; flex-direction:column; min-height:0; }
    .chat-head { padding:10px 12px; border-bottom:1px solid var(--line); background:#fff; display:flex; align-items:center; gap:10px; }
    .chat-title { font-weight:800; }
    .banner { background:#ffe082; color:#4a3b00; padding:6px 10px; border-radius:10px; display:inline-block; }
    .chat-box { flex:1; padding:12px; overflow:auto; background:#fff0f3; scroll-behavior:smooth; }
    .msg { display:inline-block; margin:6px 0; max-width:76%; padding:10px 14px; border-radius:16px; line-height:1.3; word-wrap:break-word; white-space:pre-wrap; }
    .user { background: var(--pink); color:#fff; margin-left:auto; border-bottom-right-radius:6px; }
    .girl { background:#f1f1f1; color:#000; margin-right:auto; border-bottom-left-radius:6px; }
    .meta { font-size:11px; opacity:.6; margin-top:2px; }
    .bubble img { max-width:280px; max-height:300px; border-radius:10px; display:block; object-fit:cover; }

    /* Keep the composer always visible under the chat */
    .composer { position:sticky; bottom:0; padding:10px; border-top:1px solid var(--line); background:#fff; display:flex; gap:8px; flex-wrap:wrap; }
    .composer .row { display:flex; gap:8px; width:100%; }
    .composer input[type="text"] { flex:1; min-width:260px; }
    .helper { font-size:12px; color:var(--sub); }

    .kv { display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap; }
    .kv > div { display:flex; flex-direction:column; }
    .kv input { width:240px; }

    /* NEW: Neutral system notice card (mirrors chat.html look) */
    .system-card{
      background:#ffffff;
      border:1px solid #ffd1dc;
      border-radius:12px;
      padding:12px;
      margin:8px auto;
      text-align:center;
      color:#333;
      box-shadow:0 2px 8px rgba(0,0,0,.05);
      max-width:92%;
    }
    .system-card img{ height:24px; margin-bottom:6px; }
    .system-card .title{ font-weight:800; margin-bottom:6px; }
    .system-card p{ margin:4px 0 0; font-size:14px; line-height:1.35; }
  </style>
</head>
<body>
  <header>
    <h1>Operator Console</h1>
    <div class="topbar">
      <div class="kv">
        <div>
          <label>Backend URL</label>
          <input id="backendUrl" value="https://charmr-jfmc.onrender.com" />
        </div>
        <div>
          <label>Operator Key</label>
          <input id="opKey" placeholder="OPERATOR_KEY (required for /api/operator/* endpoints)" />
        </div>
        <div>
          <label>Operator Name (shown to user)</label>
          <input id="opName" placeholder="Bella (Ops)" />
        </div>
      </div>
      <div>
        <button id="btnGlobalStart">Start Takeover (active chat)</button>
        <button id="btnGlobalStop" class="secondary">Stop Takeover</button>
      </div>
    </div>
  </header>

  <div class="app">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="side-head">
        <strong>Chats</strong>
        <button id="btnAddChat" class="ghost" title="Add chat manually">+ Add</button>
      </div>
      <div id="convList" class="side-list"></div>

      <!-- Manual add -->
      <div id="manualForm" style="padding:10px; border-top:1px solid var(--line); display:none;">
        <div style="display:flex; gap:6px; margin-bottom:6px;">
          <input id="manualUserId" type="number" placeholder="User ID" style="flex:1;">
          <input id="manualGirlId" type="number" placeholder="Girl ID" style="flex:1;">
        </div>
        <button id="btnManualAdd" style="width:100%;">Add chat</button>
      </div>

      <!-- Feed status -->
      <div class="side-foot">
        <div><strong>Feed:</strong> <span id="feedStatus">waitingâ€¦</span></div>
        <div style="margin-top:4px">Path: <code id="feedUrl">/api/operator/feed</code></div>
      </div>
    </aside>

    <!-- Main -->
    <main class="main">
      <div class="chat-head">
        <div class="chat-title" id="chatTitle">No chat selected</div>
        <span id="liveBanner" class="banner" style="display:none">ðŸ”´ Live agent is chatting</span>
      </div>
      <div id="chatBox" class="chat-box"></div>

      <div class="composer">
        <div class="row">
          <input id="textMsg" type="text" placeholder="Type a message as the girl..." />
          <button id="btnSendText">Send Text</button>
        </div>
        <div class="row">
          <input id="imageUrl" type="text" placeholder="Or paste an image URL (https://...)" />
          <input id="imageFile" type="file" accept="image/*" />
          <button id="btnSendImage">Send Image</button>
        </div>
        <div class="helper">Only chats with a user reply appear here. Newest replies stay on top.</div>
      </div>
    </main>
  </div>

  <audio id="ping" preload="auto">
    <source src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA..." type="audio/mp3">
  </audio>

  <script>
    // ---------- Config ----------
    const FEED_PATH = '/api/operator/feed';   // same as feed.html
    const FEED_LIMIT = 100;                   // initial slice
    const ONLINE_MS = 2 * 60 * 1000;          // user considered online if last user msg < 2 min
    // ----------------------------

    // Elements
    const els = {
      backendUrl: document.getElementById('backendUrl'),
      opKey: document.getElementById('opKey'),
      opName: document.getElementById('opName'),
      chatBox: document.getElementById('chatBox'),
      chatTitle: document.getElementById('chatTitle'),
      liveBanner: document.getElementById('liveBanner'),
      convList: document.getElementById('convList'),
      btnAddChat: document.getElementById('btnAddChat'),
      manualForm: document.getElementById('manualForm'),
      manualUserId: document.getElementById('manualUserId'),
      manualGirlId: document.getElementById('manualGirlId'),
      btnManualAdd: document.getElementById('btnManualAdd'),
      btnGlobalStart: document.getElementById('btnGlobalStart'),
      btnGlobalStop: document.getElementById('btnGlobalStop'),
      textMsg: document.getElementById('textMsg'),
      imageUrl: document.getElementById('imageUrl'),
      imageFile: document.getElementById('imageFile'),
      btnSendText: document.getElementById('btnSendText'),
      btnSendImage: document.getElementById('btnSendImage'),
      ping: document.getElementById('ping'),
      feedStatus: document.getElementById('feedStatus'),
      feedUrl: document.getElementById('feedUrl'),
    };

    function base(){ return (els.backendUrl.value || '').trim().replace(/\/+$/,''); }
    function headersJSON(){ return { 'Content-Type':'application/json', 'X-Operator-Key': (els.opKey.value||'').trim() }; }
    function opHeader(){ return { 'X-Operator-Key': (els.opKey.value||'').trim() }; }
    function haveOpKey(){ return (els.opKey.value||'').trim().length > 0; }

    // Store
    const store = {
      byKey: new Map(), // key: `${userId}-${girlId}`
      activeKey: null,
      lastNow: null,
      nameCache: new Map(), // userId -> "First Last"
    };
    function keyOf(u,g){ return `${Number(u)}-${Number(g)}`; }

    function ensureConv(userId, girlId, girlName){
      const k = keyOf(userId, girlId);
      if (!store.byKey.has(k)){
        store.byKey.set(k, {
          key: k,
          userId: Number(userId),
          girlId: Number(girlId),
          girlName: girlName || null,
          userName: null,
          title: `${girlName ? girlName : 'Girl '+girlId} Â· User ${userId}`,
          messages: [],
          unread: 0,
          lastTs: 0,        // last message ts (any sender)
          lastUserTs: 0,    // last USER msg ts (for sorting/online)
          hasUserReply: false,
          takeover: false
        });
      } else if (girlName) {
        const cv = store.byKey.get(k);
        if (cv && cv.title.startsWith('Girl ')) {
          cv.girlName = girlName;
          cv.title = `${girlName} Â· User ${userId}`;
        }
      }
      return store.byKey.get(k);
    }

    // --- Helpers to normalize feed rows ---
    function parseSender(r){
      if (typeof r?.from_user === 'boolean') return r.from_user ? 'user' : 'girl';
      if (typeof r?.fromUser === 'boolean')   return r.fromUser  ? 'user' : 'girl';
      const f = (r?.from || '').toString().toLowerCase();
      if (['user','u','customer'].includes(f)) return 'user';
      if (['girl','g','agent','bot'].includes(f)) return 'girl';
      return null;
    }
    function parseTimestamp(r){
      let t = r?.createdAt ?? r?.created_at ?? r?.timestamp ?? r?.ts;
      if (typeof t === 'number') return t;
      if (typeof t === 'string'){
        const num = Number(t);
        if (!Number.isNaN(num) && /^\d+$/.test(t.trim())){
          // seconds vs ms
          return t.trim().length === 10 ? num * 1000 : num;
        }
        const d = Date.parse(t);
        if (!Number.isNaN(d)) return d;
      }
      return Date.now();
    }
    function extractUserName(r){
      const first = r?.userFirstName || r?.firstName || '';
      const last  = r?.userLastName  || r?.lastName  || '';
      const name  = r?.userName || [first,last].filter(Boolean).join(' ').trim();
      return name || null;
    }

    // Contact-sharing detector (same idea as chat.html)
    function isContactAttempt(text) {
      if (!text) return false;
      const patterns = [
        /@/i,
        /\b(whats?app|telegram|snap(chat)?|instagram|insta|tg|wechat|signal|viber)\b/i,
        /\b(phone|number|call|text|dm|pm)\b/i,
        /https?:\/\/|www\./i,
        /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/,
        /\b\+?\d{1,3}[-.\s]?\d{6,14}\b/
      ];
      return patterns.some(re => re.test(text));
    }

    // ----- Sidebar -----
    function renderSidebar(autoSelectIfNone=true){
      els.convList.innerHTML = '';

      // Only show conversations where the user has replied at least once
      const listAll = [...store.byKey.values()];
      const list = listAll
        .filter(c => c.hasUserReply)
        .sort((a,b)=>{
          const au = a.lastUserTs || 0, bu = b.lastUserTs || 0;
          if (bu !== au) return bu - au;
          return (b.lastTs||0) - (a.lastTs||0);
        });

      for (const c of list){
        const item = document.createElement('div');
        item.className = 'conv' + (store.activeKey===c.key ? ' active':'');

        const metaName = c.userName ? ` (${c.userName})` : '';
        const left = document.createElement('div');
        left.innerHTML = `<strong>${c.title}</strong><div class="meta">u:${c.userId}${metaName} Â· g:${c.girlId}</div>`;
        item.appendChild(left);

        // online dot (based on lastUserTs recency)
        const online = Date.now() - (c.lastUserTs||0) < ONLINE_MS;
        const dot = document.createElement('div');
        dot.className = 'dot' + (online ? ' online' : '');
        item.appendChild(dot);

        if (c.unread>0){
          const badge = document.createElement('div');
          badge.className = 'badge';
          badge.textContent = c.unread;
          item.appendChild(badge);
        }
        item.onclick = () => selectConversation(c.key);
        els.convList.appendChild(item);
      }

      if (list.length===0){
        els.convList.innerHTML = '<div class="helper">No chats with user replies yet.</div>';
      } else if (!store.activeKey && autoSelectIfNone){
        selectConversation(list[0].key); // open the newest user-reply thread
      }

      const totalUnread = list.reduce((a,c)=>a+c.unread,0);
      document.title = totalUnread ? `(${totalUnread}) Operator Console` : 'Operator Console';
    }

    // ----- Chat -----
    function forceScrollToBottom(){
      els.chatBox.scrollTop = els.chatBox.scrollHeight;
    }

    function renderChat(conv){
      if (!conv){ els.chatTitle.textContent = 'No chat selected'; els.chatBox.innerHTML=''; return; }
      const nameSuffix = conv.userName ? ` â€” ${conv.userName}` : '';
      els.chatTitle.textContent = conv.title + nameSuffix;
      els.liveBanner.style.display = conv?.takeover ? '' : 'none';
      els.chatBox.innerHTML = '';

      for (const m of conv.messages){
        const wrap = document.createElement('div'); wrap.style.display='flex';
        const bubble = document.createElement('div'); bubble.className = 'msg ' + (m.from_user ? 'user' : 'girl');

        const content = document.createElement('div'); content.className='bubble';
        const imgMatch = /^IMAGE:\s*(\S+)/i.exec(m.text||'');
        if (imgMatch){ const img=document.createElement('img'); img.src=imgMatch[1]; img.alt='image'; content.appendChild(img); }
        else { content.textContent = m.text; }

        const meta = document.createElement('div'); meta.className='meta';
        meta.textContent = new Date(m.created_at || m.createdAt || Date.now()).toLocaleString();

        bubble.appendChild(content); bubble.appendChild(meta);
        wrap.appendChild(bubble);
        els.chatBox.appendChild(wrap);

        // Site notice (context for operator)
        if (m.from_user && isContactAttempt(m.text)) {
          const card = document.createElement('div');
          card.className = 'system-card';
          card.innerHTML = `
            <img src="logo.png" alt="Site logo">
            <div class="title">Premium Feature</div>
            <p>Sharing numbers, WhatsApp, emails or links is a Premium feature. The user sees a prompt to upgrade in chat.</p>
          `;
          els.chatBox.appendChild(card);
        }
      }
      forceScrollToBottom();
    }

    function selectConversation(key){
      store.activeKey = key;
      const conv = store.byKey.get(key);
      if (conv){ conv.unread = 0; renderSidebar(false); fetchMessages(conv); checkTakeover(conv); }
      renderChat(conv);
    }

    // ----- FEED (schema-agnostic) -----
    async function fetchFeed(initial=false){
      try{
        const params = new URLSearchParams();
        params.set('limit', String(FEED_LIMIT));
        if (!initial && store.lastNow) params.set('since', store.lastNow);

        const url = `${base()}${FEED_PATH}?${params.toString()}`;
        els.feedUrl.textContent = FEED_PATH;

        const res = await fetch(url);
        if (!res.ok){ els.feedStatus.textContent = `HTTP ${res.status}`; return; }

        const payload = await res.json();
        const rows = Array.isArray(payload?.rows) ? payload.rows : [];
        store.lastNow = payload?.now || store.lastNow;
        els.feedStatus.textContent = `ok Â· ${rows.length} rows`;

        let pingNeeded = false;

        // rows: { id, created_at/createdAt/ts, userId, girlId, girlName, from/from_user, text, [userFirstName, userLastName, userName] }
        for (const r of rows){
          const userId = Number(r.userId ?? r.user_id);
          const girlId = Number(r.girlId ?? r.girl_id);
          if (!userId || !girlId) continue;

          const cv = ensureConv(userId, girlId, r.girlName || r.girl_name || null);

          // user name if present in feed
          const maybeName = extractUserName(r);
          if (maybeName) {
            cv.userName = maybeName;
            store.nameCache.set(userId, maybeName);
          }

          const ts = parseTimestamp(r);
          if (ts > cv.lastTs) cv.lastTs = ts;

          const sender = parseSender(r);
          if (sender === 'user'){
            cv.hasUserReply = true;
            if (ts > cv.lastUserTs) cv.lastUserTs = ts;
            if (store.activeKey !== cv.key){
              cv.unread = Math.min(99, (cv.unread||0) + 1);
              pingNeeded = true;
            }
          }
        }

        if (pingNeeded){ try{ els.ping.play().catch(()=>{}); }catch{} }
        renderSidebar(initial);

      }catch(e){
        els.feedStatus.textContent = 'error (see console)';
        console.warn('Feed error:', e);
      }
    }

    // ----- Conversation fetch -----
    async function fetchMessages(conv){
      if (!conv) return;
      if (!haveOpKey()) {
        els.chatBox.innerHTML = '<div class="helper" style="padding:12px">Enter your <strong>Operator Key</strong> above to load messages for this chat.</div>';
        return;
      }

      try{
        const r = await fetch(`${base()}/api/operator/messages?userId=${conv.userId}&girlId=${conv.girlId}`, {
          headers: opHeader()
        });
        if (!r.ok) return;
        const data = await r.json();
        if (!Array.isArray(data)) return;

        conv.messages = data;
        if (data.length){
          // latest overall ts
          const last = data[data.length-1];
          conv.lastTs = new Date(last.created_at || last.createdAt || Date.now()).getTime() || Date.now();

          // RECALC lastUserTs from messages (keeps the online dot correct even if feed missed a row)
          const lastUser = [...data].reverse().find(m => m.from_user === true || m.fromUser === true);
          if (lastUser){
            const t = new Date(lastUser.created_at || lastUser.createdAt || Date.now()).getTime() || Date.now();
            conv.lastUserTs = Math.max(conv.lastUserTs || 0, t);
            conv.hasUserReply = true;
          }
        }

        // Try to resolve user name once per user (optional backend; fails silently if missing)
        if (!conv.userName && !store.nameCache.has(conv.userId)) {
          try {
            const rr = await fetch(`${base()}/api/operator/user-info?userId=${conv.userId}`, { headers: opHeader() });
            if (rr.ok) {
              const info = await rr.json();
              const nm = (info?.name) || [info?.firstName, info?.lastName].filter(Boolean).join(' ').trim();
              if (nm) {
                conv.userName = nm;
                store.nameCache.set(conv.userId, nm);
              }
            }
          } catch {}
        } else if (!conv.userName && store.nameCache.get(conv.userId)) {
          conv.userName = store.nameCache.get(conv.userId);
        }

        renderChat(conv);
        renderSidebar(false);
      }catch(e){ /* silent */ }
    }

    // ----- Takeover status -----
    async function checkTakeover(conv){
      if (!conv || !haveOpKey()) return;
      try{
        const r = await fetch(`${base()}/api/takeover/status/${conv.girlId}?userId=${conv.userId}`, {
          headers: opHeader()
        });
        if (!r.ok) return;
        const data = await r.json();
        conv.takeover = !!data.takeover;
        if (store.activeKey === conv.key){
          els.liveBanner.style.display = conv.takeover ? '' : 'none';
        }
      }catch{}
    }

    // ----- Sending -----
    async function sendText(){
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !haveOpKey()) return alert('Select a chat and enter the Operator Key');
      const text = (els.textMsg.value||'').trim();
      if (!text) return;
      try{
        const r = await fetch(`${base()}/api/operator/send`, {
          method:'POST',
          headers: headersJSON(),
          body: JSON.stringify({ userId: conv.userId, girlId: conv.girlId, text })
        });
        if (!r.ok) return alert('Failed to send text');
        els.textMsg.value = '';
        fetchMessages(conv);
      }catch{ alert('Failed to send text'); }
    }

    async function sendImage(){
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !haveOpKey()) return alert('Select a chat and enter the Operator Key');
      const url = (els.imageUrl.value||'').trim();
      const file = els.imageFile.files[0];
      if (!url && !file) return alert('Paste an image URL or choose a file');

      try{
        if (file){
          const form = new FormData();
          form.append('userId', conv.userId);
          form.append('girlId', conv.girlId);
          form.append('image', file);
          const rf = await fetch(`${base()}/api/operator/send-image`, {
            method:'POST',
            headers: opHeader(),
            body: form
          });
          if (!rf.ok) throw new Error('upload failed');
        } else {
          const rj = await fetch(`${base()}/api/operator/send-image`, {
            method:'POST',
            headers: headersJSON(),
            body: JSON.stringify({ userId: conv.userId, girlId: conv.girlId, imageUrl: url })
          });
          if (!rj.ok) throw new Error('send failed');
        }
        els.imageUrl.value=''; els.imageFile.value='';
        fetchMessages(conv);
      }catch{ alert('Failed to send image'); }
    }

    // ----- Takeover (active chat) -----
    els.btnGlobalStart.onclick = async ()=>{
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !haveOpKey()) return alert('Select a chat and enter the Operator Key');
      const body = { userId: conv.userId, girlId: conv.girlId, operatorName: (els.opName.value||'').trim() || null };
      const r = await fetch(`${base()}/api/takeover/start`, { method:'POST', headers: headersJSON(), body: JSON.stringify(body) });
      if (!r.ok) return alert('Failed to start takeover');
      conv.takeover = true; els.liveBanner.style.display = '';
    };
    els.btnGlobalStop.onclick = async ()=>{
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !haveOpKey()) return alert('Select a chat and enter the Operator Key');
      const r = await fetch(`${base()}/api/takeover/stop`, {
        method:'POST', headers: headersJSON(),
        body: JSON.stringify({ userId: conv.userId, girlId: conv.girlId })
      });
      if (!r.ok) return alert('Failed to stop takeover');
      conv.takeover = false; els.liveBanner.style.display = 'none';
    };

    // ----- Manual add -----
    els.btnAddChat.onclick = ()=>{ els.manualForm.style.display = els.manualForm.style.display ? '' : 'block'; };
    els.btnManualAdd.onclick = ()=>{
      const uid = Number(els.manualUserId.value);
      const gid = Number(els.manualGirlId.value);
      if (!uid || !gid) return;
      const c = ensureConv(uid, gid);
      c.hasUserReply = true; // force show if you add manually
      renderSidebar(); selectConversation(c.key);
      els.manualUserId.value=''; els.manualGirlId.value=''; els.manualForm.style.display = 'none';
    };

    // ----- Composer wiring -----
    els.btnSendText.onclick = sendText;
    els.btnSendImage.onclick = sendImage;
    els.textMsg.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendText(); } });

    // Keep chat pinned to bottom even on resize
    window.addEventListener('resize', ()=>{ forceScrollToBottom(); });

    // When the operator key is filled in, auto-load messages for the active chat
    els.opKey.addEventListener('input', () => {
      const c = store.byKey.get(store.activeKey);
      if (c && haveOpKey()) fetchMessages(c);
    });

    // ----- Poll -----
    setInterval(()=>fetchFeed(false), 5000);           // discover & update list
    setInterval(()=>{ const c = store.byKey.get(store.activeKey); if (c) fetchMessages(c); }, 2000); // active chat refresh

    // Boot
    (async function init(){
      await fetchFeed(true); // initial slice
    })();
  </script>
</body>
</html>
