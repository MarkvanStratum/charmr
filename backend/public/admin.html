<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Operator Console</title>
  <style>
    :root { --pink:#ef476f; --ink:#222; --bg:#fafafa; --card:#fff; --line:#e6e6e6; --sub:#6b7280; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); color:var(--ink); }
    header { padding:12px 14px; border-bottom:1px solid var(--line); background:#fff; position:sticky; top:0; z-index:3; }
    h1 { margin:0; font-size:18px; }
    .topbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px; }
    .topbar > * { margin:0; }
    label { font-weight:600; font-size:12px; color:#444; display:block; margin-bottom:4px; }
    input, button { padding:9px 10px; font-size:14px; border-radius:10px; border:1px solid var(--line); }
    input:focus { outline:2px solid #c8e3ff; border-color:#9ccaff; }
    button { background: var(--pink); color:#fff; border:none; cursor:pointer; }
    button.secondary { background:#555; }
    button.ghost { background:#fff; color:#111; border:1px solid var(--line); }
    button:disabled { opacity:.6; cursor:not-allowed; }

    /* Layout */
    .app { display:grid; grid-template-columns: 300px 1fr; height: calc(100vh - 70px); }
    .sidebar { border-right:1px solid var(--line); background:#fff; display:flex; flex-direction:column; }
    .side-head { padding:10px; border-bottom:1px solid var(--line); display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .side-list { overflow:auto; padding:8px; }
    .conv { display:flex; align-items:center; gap:8px; padding:10px; border:1px solid transparent; border-radius:10px; cursor:pointer; }
    .conv:hover { background:#fafafa; }
    .conv.active { border-color:#ffd1e0; background:#fff5f7; }
    .conv .meta { font-size:12px; color:var(--sub); }
    .badge { margin-left:auto; min-width:18px; height:18px; padding:0 6px; border-radius:999px; background:var(--pink); color:#fff; font-size:11px; display:flex; align-items:center; justify-content:center; }

    .main { display:flex; flex-direction:column; }
    .chat-head { padding:10px 12px; border-bottom:1px solid var(--line); background:#fff; display:flex; align-items:center; gap:10px; }
    .chat-title { font-weight:800; }
    .banner { background:#ffe082; color:#4a3b00; padding:6px 10px; border-radius:10px; display:inline-block; }
    .chat-box { flex:1; padding:12px; overflow:auto; background:#fff0f3; }
    .msg { display:inline-block; margin:6px 0; max-width:76%; padding:10px 14px; border-radius:16px; line-height:1.3; word-wrap:break-word; white-space:pre-wrap; }
    .user { background: var(--pink); color:#fff; margin-left:auto; border-bottom-right-radius:6px; }
    .girl { background:#f1f1f1; color:#000; margin-right:auto; border-bottom-left-radius:6px; }
    .meta { font-size:11px; opacity:.6; margin-top:2px; }
    .bubble img { max-width:280px; max-height:300px; border-radius:10px; display:block; object-fit:cover; }
    .composer { padding:10px; border-top:1px solid var(--line); background:#fff; display:flex; gap:8px; flex-wrap:wrap; }
    .composer .row { display:flex; gap:8px; width:100%; }
    .composer input[type="text"] { flex:1; min-width:260px; }
    .helper { font-size:12px; color:var(--sub); }

    .kv { display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap; }
    .kv > div { display:flex; flex-direction:column; }
    .kv input { width:240px; }
    .kv small { font-size:11px; color:var(--sub); }
  </style>
</head>
<body>
  <header>
    <h1>Operator Console</h1>
    <div class="topbar">
      <div class="kv">
        <div>
          <label>Backend URL</label>
          <input id="backendUrl" value="https://charmr-jfmc.onrender.com" />
        </div>
        <div>
          <label>Operator Key</label>
          <input id="opKey" placeholder="OPERATOR_KEY" />
        </div>
        <div>
          <label>Operator Name (shown to user)</label>
          <input id="opName" placeholder="Bella (Ops)" />
        </div>
      </div>
      <div>
        <button id="btnGlobalStart">Start Takeover (active chat)</button>
        <button id="btnGlobalStop" class="secondary">Stop Takeover</button>
      </div>
    </div>
  </header>

  <div class="app">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="side-head">
        <strong>Chats</strong>
        <button id="btnAddChat" class="ghost" title="Add chat manually">+ Add</button>
      </div>
      <div id="convList" class="side-list"></div>

      <!-- Manual add (collapsible prompt) -->
      <div id="manualForm" style="padding:10px; border-top:1px solid var(--line); display:none;">
        <div style="display:flex; gap:6px; margin-bottom:6px;">
          <input id="manualUserId" type="number" placeholder="User ID" style="flex:1;">
          <input id="manualGirlId" type="number" placeholder="Girl ID" style="flex:1;">
        </div>
        <button id="btnManualAdd" style="width:100%;">Add chat</button>
        <div class="helper" style="margin-top:6px;">Tip: chats discovered from feed will appear here automatically.</div>
      </div>
    </aside>

    <!-- Main -->
    <main class="main">
      <div class="chat-head">
        <div class="chat-title" id="chatTitle">No chat selected</div>
        <span id="liveBanner" class="banner" style="display:none">ðŸ”´ Live agent is chatting</span>
      </div>
      <div id="chatBox" class="chat-box"></div>

      <div class="composer">
        <div class="row">
          <input id="textMsg" type="text" placeholder="Type a message as the girl..." />
          <button id="btnSendText">Send Text</button>
        </div>
        <div class="row">
          <input id="imageUrl" type="text" placeholder="Or paste an image URL (https://...)" />
          <input id="imageFile" type="file" accept="image/*" />
          <button id="btnSendImage">Send Image</button>
        </div>
        <div class="helper">New user replies are auto-detected from the feed and added to the sidebar with an unread badge.</div>
      </div>
    </main>
  </div>

  <!-- tiny notification sound -->
  <audio id="ping" preload="auto">
    <source src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA..." type="audio/mp3">
  </audio>

  <script>
    // ---------- Config ----------
    const FEED_PATH = '/api/feed'; // change if your feed lives elsewhere
    // ----------------------------

    // Elements
    const els = {
      backendUrl: document.getElementById('backendUrl'),
      opKey: document.getElementById('opKey'),
      opName: document.getElementById('opName'),
      chatBox: document.getElementById('chatBox'),
      chatTitle: document.getElementById('chatTitle'),
      liveBanner: document.getElementById('liveBanner'),
      convList: document.getElementById('convList'),
      btnAddChat: document.getElementById('btnAddChat'),
      manualForm: document.getElementById('manualForm'),
      manualUserId: document.getElementById('manualUserId'),
      manualGirlId: document.getElementById('manualGirlId'),
      btnManualAdd: document.getElementById('btnManualAdd'),
      btnGlobalStart: document.getElementById('btnGlobalStart'),
      btnGlobalStop: document.getElementById('btnGlobalStop'),
      textMsg: document.getElementById('textMsg'),
      imageUrl: document.getElementById('imageUrl'),
      imageFile: document.getElementById('imageFile'),
      btnSendText: document.getElementById('btnSendText'),
      btnSendImage: document.getElementById('btnSendImage'),
      ping: document.getElementById('ping'),
    };

    function base(){ return (els.backendUrl.value || '').trim().replace(/\/+$/,''); }
    function headersJSON(){ return { 'Content-Type':'application/json', 'X-Operator-Key': (els.opKey.value||'').trim() }; }
    function authOK(){ return (els.opKey.value||'').trim().length > 0; }

    // Conversation store
    // key = `${userId}-${girlId}`
    const store = {
      byKey: new Map(),
      activeKey: null,
      lastFeedTs: 0,
    };

    function keyOf(userId, girlId){ return `${Number(userId)}-${Number(girlId)}`; }

    function ensureConv(userId, girlId){
      const k = keyOf(userId, girlId);
      if (!store.byKey.has(k)) {
        store.byKey.set(k, {
          key: k,
          userId: Number(userId),
          girlId: Number(girlId),
          title: `User ${userId} Â· Girl ${girlId}`,
          messages: [],
          unread: 0,
          lastTs: 0,
          takeover: false
        });
      }
      return store.byKey.get(k);
    }

    // -------- Sidebar rendering --------
    function renderSidebar(){
      els.convList.innerHTML = '';
      const list = [...store.byKey.values()].sort((a,b)=> (b.lastTs||0) - (a.lastTs||0));
      for (const c of list){
        const item = document.createElement('div');
        item.className = 'conv' + (store.activeKey === c.key ? ' active' : '');
        item.dataset.key = c.key;

        const title = document.createElement('div');
        title.innerHTML = `<strong>${c.title}</strong><div class="meta">u:${c.userId} Â· g:${c.girlId}</div>`;

        item.appendChild(title);

        if (c.unread > 0){
          const badge = document.createElement('div');
          badge.className = 'badge';
          badge.textContent = c.unread;
          item.appendChild(badge);
        }

        item.onclick = () => selectConversation(c.key);
        els.convList.appendChild(item);
      }

      if (store.byKey.size === 0) {
        els.convList.innerHTML = '<div class="helper">No chats discovered yet. Check your feed endpoint or operator key.</div>';
      }

      const totalUnread = list.reduce((a,c)=>a+c.unread,0);
      document.title = totalUnread>0 ? `(${totalUnread}) Operator Console` : 'Operator Console';
    }

    // -------- Chat rendering --------
    function renderChat(conv){
      els.chatTitle.textContent = conv ? conv.title : 'No chat selected';
      els.liveBanner.style.display = conv?.takeover ? '' : 'none';
      els.chatBox.innerHTML = '';
      if (!conv) return;

      for (const m of conv.messages){
        const wrap = document.createElement('div');
        wrap.style.display = 'flex';
        const bubble = document.createElement('div');
        bubble.className = 'msg ' + (m.from_user ? 'user' : 'girl');

        const content = document.createElement('div');
        content.className = 'bubble';

        const imgMatch = /^IMAGE:\s*(\S+)/i.exec(m.text||'');
        if (imgMatch){
          const img = document.createElement('img');
          img.src = imgMatch[1];
          img.alt = 'image';
          content.appendChild(img);
        } else {
          content.textContent = m.text;
        }

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = new Date(m.created_at).toLocaleString();

        bubble.appendChild(content);
        bubble.appendChild(meta);
        wrap.appendChild(bubble);
        els.chatBox.appendChild(wrap);
      }
      els.chatBox.scrollTop = els.chatBox.scrollHeight;
    }

    function selectConversation(key){
      store.activeKey = key;
      const conv = store.byKey.get(key);
      if (conv){ conv.unread = 0; renderSidebar(); fetchMessages(conv); checkTakeover(conv); }
      renderChat(conv);
    }

    // -------- Data fetching --------
    // Detect conversations from FEED (no auth required here; header sent only if present)
    async function fetchFeed(){
      try{
        const hdrs = {};
        const k = (els.opKey.value||'').trim();
        if (k) hdrs['X-Operator-Key'] = k;

        const r = await fetch(`${base()}${FEED_PATH}`, { headers: hdrs });
        if (!r.ok) { console.warn('Feed fetch failed', r.status); return; }

        const payload = await r.json();
        const rows = Array.isArray(payload?.rows) ? payload.rows : (Array.isArray(payload) ? payload : []);

        let discovered = 0;
        for (const row of rows){
          const m = normalizeFeedRow(row);
          if (!m) continue;
          if (m.from_user){
            const cv = ensureConv(m.user_id, m.girl_id);
            const ts = new Date(m.created_at).getTime() || Date.now();
            if (ts > cv.lastTs){ cv.lastTs = ts; }
            if (store.activeKey !== cv.key){
              cv.unread = Math.min(99, (cv.unread||0) + 1);
              discovered = 1;
            }
          }
        }
        if (discovered){ try{ els.ping.play().catch(()=>{}); }catch{} }
        renderSidebar();

      }catch(e){ console.warn('Feed error', e); }
    }

    // Tolerant normalizer for different feed shapes
    function normalizeFeedRow(row){
      if (!row) return null;
      const user_id = Number(row.user_id ?? row.userId ?? row.userid ?? row.u_id ?? row.uid);
      const girl_id = Number(row.girl_id ?? row.girlId ?? row.girlid ?? row.g_id ?? row.gid);

      let from_user = row.from_user ?? row.fromUser ?? (row.sender ? row.sender === 'user' : undefined) ?? row.is_user;
      if (typeof from_user === 'string') from_user = /^(true|1|user)$/i.test(from_user);
      if (typeof from_user === 'number') from_user = from_user === 1;
      from_user = !!from_user;

      const created_at = row.created_at ?? row.createdAt ?? row.ts ?? Date.now();
      const text = row.text ?? row.body ?? row.msg ?? '';

      if (!user_id || !girl_id) return null;
      return { user_id, girl_id, from_user, created_at, text };
    }

    // Load full message list for a conversation
    async function fetchMessages(conv){
      if (!conv || !authOK()) return;
      try{
        const r = await fetch(`${base()}/api/operator/messages?userId=${conv.userId}&girlId=${conv.girlId}`, {
          headers: { 'X-Operator-Key': (els.opKey.value||'').trim() }
        });
        if (!r.ok) return;
        const data = await r.json();
        if (!Array.isArray(data)) return;

        conv.messages = data;
        if (data.length){
          const last = data[data.length - 1];
          conv.lastTs = new Date(last.created_at).getTime() || Date.now();
        }
        renderChat(conv);
        renderSidebar();
      }catch(e){ /* silent */ }
    }

    // Check takeover status
    async function checkTakeover(conv){
      if (!conv || !authOK()) return;
      try{
        const r = await fetch(`${base()}/api/takeover/status/${conv.girlId}?userId=${conv.userId}`, {
          headers: { 'X-Operator-Key': (els.opKey.value||'').trim() }
        });
        if (!r.ok) return;
        const data = await r.json();
        conv.takeover = !!data.takeover;
        if (store.activeKey === conv.key){
          els.liveBanner.style.display = conv.takeover ? '' : 'none';
        }
      }catch{}
    }

    // Polling loops
    setInterval(() => { fetchFeed(); }, 5000);  // discover chats from feed
    setInterval(() => {
      const conv = store.byKey.get(store.activeKey);
      if (conv) fetchMessages(conv);
    }, 2000); // refresh active chat

    // -------- Sending --------
    async function sendText(){
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !authOK()) return alert('Select a chat first');
      const text = (els.textMsg.value||'').trim();
      if (!text) return;
      try{
        const r = await fetch(`${base()}/api/operator/send`, {
          method: 'POST',
          headers: headersJSON(),
          body: JSON.stringify({ userId: conv.userId, girlId: conv.girlId, text })
        });
        if (!r.ok) return alert('Failed to send text');
        els.textMsg.value = '';
        fetchMessages(conv);
      }catch{ alert('Failed to send text'); }
    }

    async function sendImage(){
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !authOK()) return alert('Select a chat first');

      const url = (els.imageUrl.value||'').trim();
      const file = els.imageFile.files[0];
      if (!url && !file) return alert('Paste an image URL or choose a file');

      try{
        if (file){
          const form = new FormData();
          form.append('userId', conv.userId);
          form.append('girlId', conv.girlId);
          form.append('image', file);
          const rf = await fetch(`${base()}/api/operator/send-image`, {
            method: 'POST',
            headers: { 'X-Operator-Key': (els.opKey.value||'').trim() },
            body: form
          });
          if (!rf.ok) throw new Error('upload failed');
        } else {
          const rj = await fetch(`${base()}/api/operator/send-image`, {
            method: 'POST',
            headers: headersJSON(),
            body: JSON.stringify({ userId: conv.userId, girlId: conv.girlId, imageUrl: url })
          });
          if (!rj.ok) throw new Error('send failed');
        }
        els.imageUrl.value = ''; els.imageFile.value = '';
        fetchMessages(conv);
      }catch{ alert('Failed to send image'); }
    }

    // -------- Takeover buttons (act on active chat) --------
    els.btnGlobalStart.onclick = async () => {
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !authOK()) return alert('Select a chat first');
      const body = { userId: conv.userId, girlId: conv.girlId, operatorName: (els.opName.value||'').trim() || null };
      const r = await fetch(`${base()}/api/takeover/start`, { method:'POST', headers: headersJSON(), body: JSON.stringify(body) });
      if (!r.ok) return alert('Failed to start takeover');
      conv.takeover = true; els.liveBanner.style.display = '';
    };

    els.btnGlobalStop.onclick = async () => {
      const conv = store.byKey.get(store.activeKey);
      if (!conv || !authOK()) return alert('Select a chat first');
      const r = await fetch(`${base()}/api/takeover/stop`, {
        method:'POST', headers: headersJSON(),
        body: JSON.stringify({ userId: conv.userId, girlId: conv.girlId })
      });
      if (!r.ok) return alert('Failed to stop takeover');
      conv.takeover = false; els.liveBanner.style.display = 'none';
    };

    // -------- Manual add UI --------
    els.btnAddChat.onclick = () => {
      els.manualForm.style.display = els.manualForm.style.display ? '' : 'block';
      if (els.manualForm.style.display === '') els.manualForm.style.display = 'block';
      else els.manualForm.style.display = '';
    };
    els.btnManualAdd.onclick = () => {
      const uid = Number(els.manualUserId.value);
      const gid = Number(els.manualGirlId.value);
      if (!uid || !gid) return;
      const c = ensureConv(uid, gid);
      renderSidebar();
      selectConversation(c.key);
      els.manualUserId.value=''; els.manualGirlId.value='';
      els.manualForm.style.display = 'none';
    };

    // -------- Composer wiring --------
    els.btnSendText.onclick = sendText;
    els.btnSendImage.onclick = sendImage;
    els.textMsg.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendText(); }
    });

    // -------- Boot --------
    setTimeout(fetchFeed, 200); // discover chats immediately
  </script>
</body>
</html>
